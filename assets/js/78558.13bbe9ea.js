"use strict";(self.webpackChunkofi_blog_versioned=self.webpackChunkofi_blog_versioned||[]).push([[78558],{78558:(e,n,t)=>{t.r(n),t.d(n,{default:()=>m});var i=t(67294),r=t(86010),o=t(28137),s=t(52616),l=t(46858),a=t(71217),d=t(21314);const c=t(63818),f=(0,a.Pi)((e=>{const n=(0,d.oR)("documentStore").find(e.webKey),t=n.precode+"\n"+n.code,r=n.precode.split(/\n/).length;return i.createElement("script",{id:s.h5.scriptSource(n.codeId),type:"text/py_disabled",className:"brython-script"},c+'\nrun("""'+(0,l.ly)(t||"")+'""", \''+n.codeId+"', "+r+")")}));var _=t(74981);t(56604),t(4007),t(44077),t(57787),t(82679),t(66245);const m=(0,a.Pi)((e=>{const n=(0,d.oR)("documentStore").find(e.webKey),t=i.useCallback((t=>(null!==t&&t.editor&&("python"===e.lang&&t.editor.commands.addCommand({name:"execute",bindKey:{win:"Ctrl-Enter",mac:"Command-Enter"},exec:()=>n.execScript(document)}),t.editor.commands.addCommand({name:"save",bindKey:{win:"Ctrl-s",mac:"Command-s"},exec:()=>{n.saveService.saveNow()}})),()=>{if(t&&t.editor){const e=t.editor.commands.commands.execute;e&&t.editor.commands.removeCommand(e,!0);const n=t.editor.commands.commands.save;n&&t.editor.commands.removeCommand(n,!0)}})),[n]);return i.createElement("div",{className:(0,r.default)(o.Z.brythonCodeBlock,o.Z.editor)},i.createElement(_.ZP,{className:(0,r.default)(o.Z.brythonEditor,!e.showLineNumbers&&o.Z.noGutter),style:{width:"100%"},onPaste:e=>{n.versioned&&(n.setPastedEdit(!0),n.saveService.saveNow())},focus:!1,navigateToFileEnd:!1,maxLines:25,ref:t,mode:e.lang,theme:"dracula",onChange:e=>{n.setData({code:e})},readOnly:n.showRaw||!n.loaded,value:n.showRaw?n.rawScript:n.data.code,defaultValue:n.code,name:s.h5.aceEditor(n.codeId),editorProps:{$blockScrolling:!0},setOptions:{displayIndentGuides:!0,vScrollBarAlwaysVisible:!1,highlightGutterLine:!1},showPrintMargin:!1,highlightActiveLine:!1,enableBasicAutocompletion:!0,enableLiveAutocompletion:!1,enableSnippets:!1,showGutter:e.showLineNumbers}),"python"===e.lang&&i.createElement(f,{webKey:e.webKey}))}))},63818:e=>{e.exports="from browser import document, window\nimport re\nimport sys\nimport time\n\nhas_turtle_import = False\nlog_line_number_shift = 0\n\ndef notify(node_id, data):\n    event = window.CustomEvent.new('bry_notify', {'detail': data})\n    document[f'py_{node_id}'].dispatchEvent(event)\n\nclass EventOutput:\n    encoding = 'utf-8'\n\n    def __init__(self, node_id, out_type):\n        self.node_id = node_id\n        self.out_type = out_type\n        self.buf = ''\n\n    def write(self, data):\n        self.buf += str(data)\n        self.flush()\n\n    def flush(self):\n        if len(self.buf) > 0:\n            notify(self.node_id, {'type': self.out_type, 'output': self.buf})\n        self.buf = ''\n\n    def __len__(self):\n        return len(self.buf)\n\nclass Trace:\n    def __init__(self):\n        self.buf = \"\"\n\n    def write(self, *data):\n        self.buf += \" \".join([str(x) for x in data])\n\n    def format(self):\n        \"\"\"Remove calls to function in this script from the traceback.\"\"\"\n        return self.buf\n\ndef syntax_error(args):\n    trace = Trace()\n    info, [filename, lineno, offset, line, *extra] = args\n    line_nr = lineno - log_line_number_shift if lineno > 0 else 0\n\n    trace.write(f\"  File {filename}, line {line_nr}\\n\")\n    indent = len(line) - len(line.lstrip())\n    trace.write(\"    \" + line.strip() + \"\\n\")\n    nb_marks = 1\n    if extra:\n        end_lineno, end_offset = extra\n        if end_lineno > lineno:\n            nb_marks = len(line) - offset\n        else:\n            nb_marks = end_offset - offset\n    nb_marks = max(nb_marks, 1)\n    trace.write(\"    \" + (offset - 1) * \" \" + \"^\" * nb_marks + \"\\n\")\n    trace.write(\"SyntaxError:\", info, \"\\n\")\n    return trace.buf\n\ndef format_exc():\n    trace = Trace()\n    exc_info = sys.exc_info()\n    exc_class = exc_info[0].__name__\n    exc_msg = str(exc_info[1])\n    tb = exc_info[2]\n    if exc_info[0] is SyntaxError:\n        return syntax_error(exc_info[1].args)\n    trace.write(\"Traceback (most recent call last):\\n\")\n    while tb is not None:\n        frame = tb.tb_frame\n        code = frame.f_code\n        name = code.co_name\n        filename = code.co_filename\n        line_nr = tb.tb_lineno - log_line_number_shift if tb.tb_lineno > 0 else 0\n        trace.write(f\"  File {filename}, line {line_nr}, in {name}\\n\")\n        if not filename.startswith(\"<\"):\n            src = open(filename, encoding='utf-8').read()\n            lines = src.split('\\n')\n            line = lines[tb.tb_lineno - 1]\n            trace.write(f\"    {line.strip()}\\n\")\n        tb = tb.tb_next\n    trace.write(f\"{exc_class}: {exc_msg}\\n\")\n    return trace.format()\n\ndef print_exc(file=None):\n    if file is None:\n        file = sys.stderr\n    trace = format_exc()\n    file.write(trace)\n    return trace\n\nTURTLE_IMPORTS = re.compile(r'(^from turtle import)|(^import turtle)', re.M)\nTURTLE_TEMPLATE = '''from browser import document\nimport turtle\nturtle.restart()\nturtle.set_defaults(\n  turtle_canvas_wrapper = document['{node_id}_turtle_result'],\n  turtle_canvas_id = '{node_id}_svg'\n)\n{py_script}\nturtle.done()\n'''\n\n\ndef run(code, node_id, line_shift):\n    global has_turtle_import, log_line_number_shift\n    has_turtle_import = len(TURTLE_IMPORTS.findall(code)) > 0\n    log_line_number_shift = (7 if has_turtle_import else 0) + line_shift\n    py_script = TURTLE_TEMPLATE.format(node_id=node_id, py_script=code) if has_turtle_import else code\n\n    sys.stdout = EventOutput(node_id, 'stdout')\n    sys.stderr = EventOutput(node_id, 'stderr')\n    notify(node_id, {'type': 'start', 'time': time.time()})\n    try:\n        res_div = f'{node_id}_brython_result'\n        document[res_div].clear()\n        ns = {'__name__': node_id, 'RESULT_DIV': document[res_div]}\n        loc = {}\n        exec(py_script, ns)\n        # if len(code.splitlines()) < 10:\n        #    print('  --', '\\n'.join([f'{x}: {loc[x]}' for x in loc.keys() if not x.startswith('__')]))\n    except Exception as exc:\n        print_exc(file=sys.stderr)\n    finally:\n        notify(node_id, {'type': 'done', 'time': time.time()})\n    \n    sys.stdout.flush()\n    sys.stderr.flush()\n"}}]);