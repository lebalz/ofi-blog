---
title: Zeichencodierung
---

import AsciiEncoding from "@site/src/components/AsciiEncoding";
import Video from "@site/src/components/Video";


# Zeichencodierung

Datenpakete bestehen aus verschiedenen Zahlen und Zeichen. Wie lassen sich diese in Einsen und Nullen √ºbersetzen? Auf dem Computer ist jedem Zeichen eine eindeutige Zahl zugeordnet - eine sog. **Zeichencodierung**. Eine g√§ngige Zeichencodierung ist etwa [ASCII, 128 Zeichen](https://de.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange), wobei f√ºr ein Zeichen genau `7 bit`, also 7 Stellen mit `0` oder `1`, notwendig sind. In diesen 128 m√∂glichen Zeichen sind `33` Steuerzeichen und `95` normale Zeichen enthalten.

**Steuerzeichen** sind spezielle Zeichen wie bspw. das Zeichen `\n` f√ºr einen Zeilenumbruch oder `\t` f√ºr einen Tabulator.

Die ASCII-Codierung enth√§lt noch keine Umlaute, weshalb mit [Latin 1, 256 Zeichen](https://de.wikipedia.org/wiki/ISO_8859-1) der Informationsgehalt um ein Bit erh√∂ht wurde, so dass insgesamt `256` Zeichen codiert werden k√∂nnen - die ersten `128` Zeichen sind dabei identische mit ASCII.

<details className="small-table" ><summary>Latin 1 Tabelle</summary>

<AsciiEncoding />

| Zeichen | Zahl | Bin√§r      |
| :------ | :--- | :--------- |
|         | 0    | `00000000` |
|         | 1    | `00000001` |
|         | 2    | `00000010` |
|         | 3    | `00000011` |
|         | 4    | `00000100` |
|         | 5    | `00000101` |
|         | 6    | `00000110` |
|         | 7    | `00000111` |
|         | 8    | `00001000` |
| `\t`    | 9    | `00001001` |
| `\n`    | 10   | `00001010` |
|         | 11   | `00001011` |
|         | 12   | `00001100` |
|         | 13   | `00001101` |
|         | 14   | `00001110` |
|         | 15   | `00001111` |
|         | 16   | `00010000` |
|         | 17   | `00010001` |
|         | 18   | `00010010` |
|         | 19   | `00010011` |
|         | 20   | `00010100` |
|         | 21   | `00010101` |
|         | 22   | `00010110` |
|         | 23   | `00010111` |
|         | 24   | `00011000` |
|         | 25   | `00011001` |
|         | 26   | `00011010` |
|         | 27   | `00011011` |
|         | 28   | `00011100` |
|         | 29   | `00011101` |
|         | 30   | `00011110` |
|         | 31   | `00011111` |
|         | 32   | `00100000` |
| !       | 33   | `00100001` |
| "       | 34   | `00100010` |
| #       | 35   | `00100011` |
| $       | 36   | `00100100` |
| %       | 37   | `00100101` |
| &       | 38   | `00100110` |
| '       | 39   | `00100111` |
| (       | 40   | `00101000` |
| )       | 41   | `00101001` |
| \*      | 42   | `00101010` |
| +       | 43   | `00101011` |
| ,       | 44   | `00101100` |
| -       | 45   | `00101101` |
| .       | 46   | `00101110` |
| /       | 47   | `00101111` |
| 0       | 48   | `00110000` |
| 1       | 49   | `00110001` |
| 2       | 50   | `00110010` |
| 3       | 51   | `00110011` |
| 4       | 52   | `00110100` |
| 5       | 53   | `00110101` |
| 6       | 54   | `00110110` |
| 7       | 55   | `00110111` |
| 8       | 56   | `00111000` |
| 9       | 57   | `00111001` |
| :       | 58   | `00111010` |
| ;       | 59   | `00111011` |
| <       | 60   | `00111100` |
| =       | 61   | `00111101` |
| >       | 62   | `00111110` |
| ?       | 63   | `00111111` |
| @       | 64   | `01000000` |
| A       | 65   | `01000001` |
| B       | 66   | `01000010` |
| C       | 67   | `01000011` |
| D       | 68   | `01000100` |
| E       | 69   | `01000101` |
| F       | 70   | `01000110` |
| G       | 71   | `01000111` |
| H       | 72   | `01001000` |
| I       | 73   | `01001001` |
| J       | 74   | `01001010` |
| K       | 75   | `01001011` |
| L       | 76   | `01001100` |
| M       | 77   | `01001101` |
| N       | 78   | `01001110` |
| O       | 79   | `01001111` |
| P       | 80   | `01010000` |
| Q       | 81   | `01010001` |
| R       | 82   | `01010010` |
| S       | 83   | `01010011` |
| T       | 84   | `01010100` |
| U       | 85   | `01010101` |
| V       | 86   | `01010110` |
| W       | 87   | `01010111` |
| X       | 88   | `01011000` |
| Y       | 89   | `01011001` |
| Z       | 90   | `01011010` |
| [       | 91   | `01011011` |
| \\      | 92   | `01011100` |
| ]       | 93   | `01011101` |
| ^       | 94   | `01011110` |
| \_      | 95   | `01011111` |
| \`      | 96   | `01100000` |
| a       | 97   | `01100001` |
| b       | 98   | `01100010` |
| c       | 99   | `01100011` |
| d       | 100  | `01100100` |
| e       | 101  | `01100101` |
| f       | 102  | `01100110` |
| g       | 103  | `01100111` |
| h       | 104  | `01101000` |
| i       | 105  | `01101001` |
| j       | 106  | `01101010` |
| k       | 107  | `01101011` |
| l       | 108  | `01101100` |
| m       | 109  | `01101101` |
| n       | 110  | `01101110` |
| o       | 111  | `01101111` |
| p       | 112  | `01110000` |
| q       | 113  | `01110001` |
| r       | 114  | `01110010` |
| s       | 115  | `01110011` |
| t       | 116  | `01110100` |
| u       | 117  | `01110101` |
| v       | 118  | `01110110` |
| w       | 119  | `01110111` |
| x       | 120  | `01111000` |
| y       | 121  | `01111001` |
| z       | 122  | `01111010` |
| {       | 123  | `01111011` |
| \|      | 124  | `01111100` |
| }       | 125  | `01111101` |
| ~       | 126  | `01111110` |
|        | 127  | `01111111` |
| ¬Ä        | 128  | `10000000` |
| ¬Å        | 129  | `10000001` |
| ¬Ç        | 130  | `10000010` |
| ¬É        | 131  | `10000011` |
| ¬Ñ        | 132  | `10000100` |
| ¬Ö        | 133  | `10000101` |
| ¬Ü        | 134  | `10000110` |
| ¬á        | 135  | `10000111` |
| ¬à        | 136  | `10001000` |
| ¬â        | 137  | `10001001` |
| ¬ä        | 138  | `10001010` |
| ¬ã        | 139  | `10001011` |
| ¬å        | 140  | `10001100` |
|         | 141  | `10001101` |
|         | 142  | `10001110` |
|         | 143  | `10001111` |
|         | 144  | `10010000` |
| ¬ë        | 145  | `10010001` |
| ¬í        | 146  | `10010010` |
| ¬ì        | 147  | `10010011` |
| ¬î        | 148  | `10010100` |
| ¬ï        | 149  | `10010101` |
| ¬ñ        | 150  | `10010110` |
| ¬ó        | 151  | `10010111` |
| ¬ò        | 152  | `10011000` |
| ¬ô        | 153  | `10011001` |
| ¬ö        | 154  | `10011010` |
| ¬õ        | 155  | `10011011` |
| ¬ú        | 156  | `10011100` |
|         | 157  | `10011101` |
|         | 158  | `10011110` |
| ¬ü        | 159  | `10011111` |
|         | 160  | `10100000` |
| ¬°       | 161  | `10100001` |
| ¬¢       | 162  | `10100010` |
| ¬£       | 163  | `10100011` |
| ¬§       | 164  | `10100100` |
| ¬•       | 165  | `10100101` |
| ¬¶       | 166  | `10100110` |
| ¬ß       | 167  | `10100111` |
| ¬®       | 168  | `10101000` |
| ¬©       | 169  | `10101001` |
| ¬™       | 170  | `10101010` |
| ¬´       | 171  | `10101011` |
| ¬¨       | 172  | `10101100` |
|         | 173  | `10101101` |
| ¬Æ       | 174  | `10101110` |
| ¬Ø       | 175  | `10101111` |
| ¬∞       | 176  | `10110000` |
| ¬±       | 177  | `10110001` |
| ¬≤       | 178  | `10110010` |
| ¬≥       | 179  | `10110011` |
| ¬¥       | 180  | `10110100` |
| ¬µ       | 181  | `10110101` |
| ¬∂       | 182  | `10110110` |
| ¬∑       | 183  | `10110111` |
| ¬∏       | 184  | `10111000` |
| ¬π       | 185  | `10111001` |
| ¬∫       | 186  | `10111010` |
| ¬ª       | 187  | `10111011` |
| ¬º       | 188  | `10111100` |
| ¬Ω       | 189  | `10111101` |
| ¬æ       | 190  | `10111110` |
| ¬ø       | 191  | `10111111` |
| √Ä       | 192  | `11000000` |
| √Å       | 193  | `11000001` |
| √Ç       | 194  | `11000010` |
| √É       | 195  | `11000011` |
| √Ñ       | 196  | `11000100` |
| √Ö       | 197  | `11000101` |
| √Ü       | 198  | `11000110` |
| √á       | 199  | `11000111` |
| √à       | 200  | `11001000` |
| √â       | 201  | `11001001` |
| √ä       | 202  | `11001010` |
| √ã       | 203  | `11001011` |
| √å       | 204  | `11001100` |
| √ç       | 205  | `11001101` |
| √é       | 206  | `11001110` |
| √è       | 207  | `11001111` |
| √ê       | 208  | `11010000` |
| √ë       | 209  | `11010001` |
| √í       | 210  | `11010010` |
| √ì       | 211  | `11010011` |
| √î       | 212  | `11010100` |
| √ï       | 213  | `11010101` |
| √ñ       | 214  | `11010110` |
| √ó       | 215  | `11010111` |
| √ò       | 216  | `11011000` |
| √ô       | 217  | `11011001` |
| √ö       | 218  | `11011010` |
| √õ       | 219  | `11011011` |
| √ú       | 220  | `11011100` |
| √ù       | 221  | `11011101` |
| √û       | 222  | `11011110` |
| √ü       | 223  | `11011111` |
| √†       | 224  | `11100000` |
| √°       | 225  | `11100001` |
| √¢       | 226  | `11100010` |
| √£       | 227  | `11100011` |
| √§       | 228  | `11100100` |
| √•       | 229  | `11100101` |
| √¶       | 230  | `11100110` |
| √ß       | 231  | `11100111` |
| √®       | 232  | `11101000` |
| √©       | 233  | `11101001` |
| √™       | 234  | `11101010` |
| √´       | 235  | `11101011` |
| √¨       | 236  | `11101100` |
| √≠       | 237  | `11101101` |
| √Æ       | 238  | `11101110` |
| √Ø       | 239  | `11101111` |
| √∞       | 240  | `11110000` |
| √±       | 241  | `11110001` |
| √≤       | 242  | `11110010` |
| √≥       | 243  | `11110011` |
| √¥       | 244  | `11110100` |
| √µ       | 245  | `11110101` |
| √∂       | 246  | `11110110` |
| √∑       | 247  | `11110111` |
| √∏       | 248  | `11111000` |
| √π       | 249  | `11111001` |
| √∫       | 250  | `11111010` |
| √ª       | 251  | `11111011` |
| √º       | 252  | `11111100` |
| √Ω       | 253  | `11111101` |
| √æ       | 254  | `11111110` |
| √ø       | 255  | `11111111` |

</details>

### Text -> Bin√§r

Jedes Zeichen auf der Tastatur hat eine feste Zahl zugeordnet. In Python l√§sst sich ein Zeichen leicht in die entsprechende Zahl √ºbersetzen:

```py live_py slim
zeichen = 'g'
zahl = ord(zeichen)
print(zeichen, '->', zahl)
```

Dargestellt wird eine Zahl im Dezimalsystem, daher mit der Basis `10`. Um ins Bin√§re Zahlensystem mit der Basis 2 zu wechseln, kann die Funktion `bin` verwendet werden:

```py live_py slim
bin_zahl = bin(108)
print(bin_zahl)

# Python-Zusatzinformationen √ºber den Datentyp weglassen:
bin_zahl = bin_zahl[2:]  # start beim dritten Zeichen
print(bin_zahl)

# auf 1 byte = 8 bit erg√§nzen
bin_zahl = bin_zahl.zfill(8)
print(bin_zahl)
```

:::aufgabe
Wandeln Sie Ihren Namen in Bin√§r-Code um, indem Sie

- zuerst jeden `buchstaben` in eine Zahl umwandeln
- dann die Zahl ins bin√§re √ºbersetzen
- und schliesslich die bin√§re Zeichenkette mit `print` ausgeben

```py live_py title=bin--name.py
name = 'Reto'
for buchstabe in name:
    print(buchstabe)
```

:::

### Bin√§r -> Text

Versuchen Sie nachzuvollziehen, was der folgende Code macht. Erinnerung: `int` wandelt einen Text in eine Zahl um, `chr` steht f√ºr "Character" und gibt f√ºr eine Zahl das entsprechend codierte Zeichen zur√ºck.

```py live_py slim
code = '01000111'

# in Zahl umwandeln
zahl = int(code)
print('Versuch 1', zahl) # geht nicht, wieso?

zahl = int(code, 2)
print('Versuch 2', zahl)

# in Zeichen umwandeln
print('Zeichen', chr(zahl))
```

:::aufgabe
Wandeln Sie die bin√§re Folge wieder um in Text. Was kommt dabei raus?

```py live_py title=name.py
binaer = ['01000111','01000010','01010011','01001100']
for code in binaer:
    print(code)
```

<details><summary>‚≠êÔ∏è Zusatz 1</summary>
K√∂nnen Sie das √ºbersetzte Wort auch auf einer einzigen Zeile ausgeben?
</details>
<details><summary>‚≠êÔ∏è Zusatz 2</summary>

Die folgende Funktion wandelt eine Text-Kette aus Bin√§r-Zahlen in eine Liste mit Bin√§r-Zahlen von `8bit` l√§nge um. Verwenden Sie diese Funktion, um eine beliebige Zeichenkette in Text umzuwandeln.

```py live_py
def to_8bit(bin_text):
    return [bin_text[i:i + 8] for i in range(0, len(bin_text), 8)]

binaer = to_8bit('01000111010000100101001101001100')
print(binaer)
```

</details>

<details><summary>L√∂sung</summary>

```py
binaer = ['01000111','01000010','01010011','01001100']
for code in binaer:
    zahl = int(code, 2)
    print(chr(zahl))
```

</details>
:::


## Bin√§rer Decodierer

<Video 
    src={require('./images/paper_tape_shapolab.mp4').default}
    expanded
>

Quelle: [Twitter](https://twitter.com/shapoco/status/1373534314961326092)

</Video>

:::aufgabe

Der bin√§re Code befindet sich auf der linken Seite. Wozu braucht es die zweite, rechte Spur? 
:::

## Unicode / UTF-8 [^1]

### Unicode

[Unicode](https://de.wikipedia.org/wiki/Unicode) ist ein internationaler Standard f√ºr Schriftzeichen und Symbole. Das Unicode-Konsortium erstellt einen Katalog von allen sinnvollen Schriftzeichen, welcher st√§ndig erweitert wird. In der Version 12.1, welche im Mai 2019 ver√∂ffentlicht wurde, umfasst Unicode $137'929$ Zeichen.

Hier sind ein paar Zeichen aufgef√ºhrt, um zu illustrieren wie umfangreich Unicode ist:

:::cards --cols=4 --min=150px
![](images/unicode-0041.png)
[Lateinischer Grossbuchstaben A `U+0041`](https://unicode-table.com/de/0041/)
***
![](images/unicode-3084.png)
[Hiragana-Buchstabe Ya `U+3084`](https://unicode-table.com/de/3084/)
***
![](images/unicode-13CD.png)
[Cherokee-Buchstabe S `U+13CD`](https://unicode-table.com/de/13CD/)
***
![](images/unicode-1F0B9.png)
[Spielkarte Neun der Herzen `U+1F0B9`](https://unicode-table.com/de/1F0B9/)
***
![](images/unicode-1F92F.png)
[Entsetztes Gesicht mit explodierendem Kopf `U+1F92F`](https://unicode-table.com/de/1F92F/)
***
![](images/unicode-1F412.png)
[Affe `U+1F412`](https://unicode-table.com/de/1F412/)
***
![](images/unicode-23FB.png)
[Power-Symbol `U+23FB`](https://unicode-table.com/de/23FB/)
***
![](images/unicode-1322C.png)
[√Ñgyptische Hieroplyphe Nl012 `U+1322C`](https://unicode-table.com/de/1322C/)
:::

Quelle: [UT - Unicode Table](https://unicode-table.com/de/)

Jedem Unicode-Zeichen hat eine eindeutige Unicode-Nummer, welche h√§ufig als hexadezimale Zahl geschrieben wird.

### UTF-8

**UTF-8** ist ein Code, der Unicode-Zeichen in Bitmuster √ºbersetzt. Ein Unicode-Zeichen wird mit ein bis vier Byte (daher 8-32 bit) dargestellt. Die folgende Tabelle zeigt, wie die Codierung funktioniert:

| Unicode-Bereich | Bitmuster                             | Anzahl Bit |
| :-------------- | :------------------------------------ | ---------: |
| 0 bis 127       | `0xxxxxxx`                            |          7 |
| 128 bis 2047    | `110xxxxx 10xxxxxx`                   |         11 |
| 2048 bis 65535  | `1110xxxx 10xxxxxx 10xxxxxx`          |         16 |
| ab 65536        | `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx` |         21 |

Unicode-Zeichen mit einer Nummer zwischen 0 und 127 werden mit einem Byte dargestellt, welches mit `0` beginnt. Somit ist UTF-8 in diesem Bereich identisch mit ASCII (und Latin 1).

F√ºr die anderen Zeichen wird mehr als ein Byte verwendet. Dabei beginnt jedes Byte mit einer oder mehreren `1`, gefolgt von einer `0`. Die Anzahl `1` im ersten Byte definieren, wie viele Bytes f√ºr das Zeichen verwendet werden. Die folgenden Bytes werden mit `10` markiert. Die `x` werden mit der Bin√§rdarstellung der Unicode-Nummer aufgef√ºllt.

| Zeichen                       | Nummer |                             Bitmuster |
| :---------------------------- | -----: | ------------------------------------: |
| A                             |     65 |                            `01000001` |
| √§                             |    228 |                   `11000011 10100100` |
| Schwarze Sonne mit Strahlen ‚òÄ |   9728 |          `11100010 10011000 10000000` |
| Affe üêí                       | 128018 | `11110000 10011111 10010000 10010010` |

Der Vorteil dieser Codierung ist, dass am Beginn eines Bytes erkannt wird, ob es sich um den Anfang die Fortsetzung eines Zeichens handelt.

| Beginn | Bedeutung                                     |
| :----- | :-------------------------------------------- |
| 0‚Ä¶     | ASCII-Zeichen                                 |
| 10‚Ä¶    | Fortsetzung eines Zeichens mit mehreren Bytes |
| 110‚Ä¶   | Beginn eines Zeichens mit zwei Bytes          |
| 1110‚Ä¶  | Beginn eines Zeichens mit drei Bytes          |
| 11110‚Ä¶ | Beginn eines Zeichens mit vier Bytes          |

Dies wird deutlich, wenn man dies als Bin√§rbaum darstellt:

![UTF-8 Pr√§fix](images/utf-8-prefix.svg)

## Mehrstufige Codierung [^2]


Oft werden Informationen mehrstufig codiert. So wird beispielsweise die Information ¬´Ich bin m√ºde.¬ª als Emoji dargestellt. Das Handy ordnet dem Emoji die entsprechende Unicode-Nummer zu. Diese wird mit UTF-8 in eine Bitfolge √ºbersetzt, welche √ºber das Mobilfunknetz √ºbermittelt wird.

Das Handy des Empf√§ngers √ºbersetzt die Bitfolge wieder zur√ºck in eine Unicode-Nummer und das entsprechende Emoji. Die Interpretation des Emojis muss vom Empf√§nger selbst vorgenommen werden.

![Unicode zu UTF-8](images/unicode.svg)

[^1]: Quelle [rothe.io](https://rothe.io/?page=code/3-text/4-unicode/)
[^2]: Quelle [rothe.io](https://rothe.io/?page=code/3-text/5-code/)
